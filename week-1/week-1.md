For decades, as developers we are confronted with a problem to solve - how to prevent our applications from blocking. Whether we're developing desktop, mobile, or even server-side applications, we want to avoid having the user wait or what's worse cause bottlenecks that would prevent an application from scaling.

There have been many approaches to solving this problem

* Threading

* Callbacks

* Futures, promises, and others

* Reactive Extensions
  * https://youtu.be/n6nCHpy3YeM
  * https://youtu.be/KOjC3RhwKU4

* Coroutines
  * https://github.com/Kotlin/coroutines-examples
  * https://dev.to/_pritam_kadam_/everything-you-need-to-know-about-kotlin-coroutines-4bfg
  * https://medium.com/swlh/coroutines-tips-and-tricks-callbacks-synchronous-way-to-work-with-asynchronous-code-b9fb840fb793
  * https://medium.com/livefront/coroutine-misconceptions-whose-context-is-it-anyway-320c0b7adcc7
  * https://hossainkhan.medium.com/kotlin-coroutines-error-handling-strategy-runcatching-and-result-class-14e1467ced6
  * https://elizarov.medium.com/the-reason-to-avoid-globalscope-835337445abc
  * https://twitter.com/androiddevnotes/status/1346433566465433601
  
  * Flow
     * Orange
     
  * Testing
     * Orange


###  Android
  * https://medium.com/@faizanwar027/asynchronous-programming-in-android-22965c11cf34
  * https://developer.android.com/kotlin/coroutines
  * https://medium.com/androiddevelopers/repeatonlifecycle-api-design-story-8670d1a7d333

https://kotlinlang.org/docs/async-programming.html

https://youtu.be/n6nCHpy3YeM
